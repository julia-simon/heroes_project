# Heroes Battle — Student Task

В данном проекте реализованы алгоритмы, необходимые для симуляции боя между армией игрока и армией компьютера.
Реализация выполнена в соответствии с интерфейсами, предоставленными в исходном коде игры.

---

## Реализованные алгоритмы

### 1. Генерация армии компьютера (`GeneratePreset.generate`)

Жадный алгоритм с сортировкой по коэффициенту эффективности.

Метод `generate` формирует армию компьютера на основе списка доступных типов юнитов и ограничения по очкам (`maxPoints`).

Алгоритм работы:
1. Список типов юнитов сортируется по эффективности:
    - эффективность рассчитывается как `(атака + здоровье) / стоимость`;
2. Для каждого типа юнита создаётся не более 11 экземпляров;
3. Добавление юнитов продолжается до исчерпания доступных очков;
4. Юниты размещаются на фиксированной стороне поля (левая часть, координаты X = 0..2);
5. По вертикали (Y) координаты выбираются случайным образом без пересечений.

Таким образом обеспечивается:
- соблюдение ограничения на количество юнитов одного типа;
- соблюдение ограничения по очкам;
- формирование сбалансированной армии.

#### Алгоритмическая сложность

Пусть:
- `n` - количество типов юнитов;
- `m` - максимальное количество юнитов одного типа (в данной задаче `m = 11`).

Алгоритм выполняет:
- сортировку списка типов юнитов: **O(n log n)**;
- вложенный цикл добавления юнитов: **O(n · m)**.

Итоговая сложность: **O(n · m)**

Так как `m` ограничено константой, сложность алгоритма соответствует требованиям задания.

---

### 2. Поиск доступных для атаки юнитов (`SuitableForAttackUnitsFinder.getSuitableUnits`)

Линейный поиск с фильтрацией.

Метод определяет список юнитов, которые могут быть атакованы в текущий момент.

Алгоритм работы:
1. Юниты группируются по слоям поля (координата X);
2. В зависимости от стороны атаки порядок обхода слоёв меняется;
3. Для каждой вертикальной линии (координата Y) выбирается первый живой юнит;
4. Остальные юниты на той же линии считаются недоступными для атаки.

Алгоритм предотвращает атаки через других юнитов и корректно определяет фронтовые цели.

#### Алгоритмическая сложность

Пусть:
- `n` - общее количество юнитов на поле.

Каждый юнит просматривается не более одного раза.

Итоговая сложность: **O(n)**

---

### 3. Поиск кратчайшего пути к цели (`UnitTargetPathFinder.getTargetPath`)

Поиск в ширину (BFS) на прямоугольной сетке

Метод ищет кратчайший путь между атакующим и атакуемым юнитом с учётом препятствий.

Алгоритм работы:
1. Игровое поле представляется в виде двумерной сетки;
2. Все живые юниты (кроме атакующего и цели) считаются препятствиями;
3. Используется поиск в ширину (BFS) для нахождения кратчайшего пути;
4. После достижения цели путь восстанавливается с помощью массива предков.

#### Алгоритмическая сложность

Пусть:
- `W` — ширина поля;
- `H` — высота поля.

BFS в худшем случае посещает все клетки поля.

Итоговая сложность: **O(W · H)**

Так как размеры поля фиксированы, алгоритм работает за линейное время относительно размера игрового поля.

---

### 4. Симуляция боя (`SimulateBattle.simulate`)

Раундовая пошаговая симуляция с сортировкой приоритетов

Метод осуществляет пошаговую симуляцию боя между армией игрока и армией компьютера.

Алгоритм работы:
1. Пока в обеих армиях есть живые юниты, выполняются раунды боя;
2. В начале каждого раунда формируется единая очередь всех живых юнитов обеих армий;
3. Очередь сортируется по убыванию базовой атаки;
4. Каждый юнит совершает не более одного хода за раунд;
5. Атака выполняется через `unit.getProgram().attack()`;
6. После каждой атаки выводится лог боя;
7. После завершения всех ходов начинается следующий раунд;
8. Симуляция завершается, когда одна из армий полностью уничтожена.

#### Алгоритмическая сложность

Пусть:
- `n` — количество юнитов игрока;
- `m` — количество юнитов компьютера;
- `r` — количество раундов боя.

На каждом раунде выполняется:
- сбор очереди: **O(n + m)**;
- сортировка очереди: **O((n + m) log (n + m))**;
- выполнение ходов: **O(n + m)**.

Итоговая сложность: **O(r · (n + m) log (n + m))**

Все алгоритмы реализованы в соответствии с требованиями задания.
Алгоритмическая сложность методов не превышает заявленные ограничения и соответствует ожидаемым характеристикам игрового процесса.
